/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.render

import net.ccbluex.liquidbounce.event.Render2DEvent
import net.ccbluex.liquidbounce.event.Render3DEvent
import net.ccbluex.liquidbounce.event.handler
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.ui.font.Fonts
import net.ccbluex.liquidbounce.utils.block.block
import net.ccbluex.liquidbounce.utils.extensions.*
import net.ccbluex.liquidbounce.utils.render.RenderUtils.drawBorderedRect
import net.ccbluex.liquidbounce.utils.render.RenderUtils.drawFilledBox
import net.ccbluex.liquidbounce.utils.render.RenderUtils.drawSelectionBoundingBox
import net.ccbluex.liquidbounce.utils.render.RenderUtils.glColor
import net.minecraft.block.Block
import net.minecraft.client.gui.ScaledResolution
import net.minecraft.client.renderer.GlStateManager.resetColor
import net.minecraft.init.Blocks
import net.minecraft.util.BlockPos
import org.lwjgl.opengl.GL11.*
import java.awt.Color

object BlockOverlay : Module("BlockOverlay", Category.RENDER, gameDetecting = false) {
    private val mode by choices("Mode", arrayOf("Box", "OtherBox", "Outline"), "Box")
    private val depth3D by boolean("Depth3D", false)
    private val thickness by float("Thickness", 2F, 1F..5F)

    val info by boolean("Info", false)

    private val color by color("Color", Color(68, 117, 255, 100))

    val currentBlock: BlockPos?
        get() {
            val world = mc.theWorld ?: return null
            val blockPos = mc.objectMouseOver?.blockPos ?: return null

            if (blockPos.block !in arrayOf(
                    Blocks.air,
                    Blocks.water,
                    Blocks.lava
                ) && world.worldBorder.contains(blockPos)
            )
                return blockPos

            return null
        }

    val onRender3D = handler<Render3DEvent> {
        val blockPos = currentBlock ?: return@handler

        val block = blockPos.block ?: return@handler

        glEnable(GL_BLEND)
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
        glEnable(GL_LINE_SMOOTH)
        glHint(GL_LINE_SMOOTH_HINT, GL_NICEST)
        glColor(color)
        glLineWidth(thickness)
        glDisable(GL_TEXTURE_2D)
        if (depth3D) glDisable(GL_DEPTH_TEST)
        glDepthMask(false)

        block.setBlockBoundsBasedOnState(mc.theWorld, blockPos)

        val thePlayer = mc.thePlayer ?: return@handler

        val pos = thePlayer.interpolatedPosition(thePlayer.lastTickPos)

        val f = 0.002F.toDouble()

        val axisAlignedBB = block.getSelectedBoundingBox(mc.theWorld, blockPos).expand(f, f, f).offset(-pos)

        if (mode.lowercase() in arrayOf("box", "otherbox"))
            drawFilledBox(axisAlignedBB)
        if (mode.lowercase() in arrayOf("box", "outline"))
            drawSelectionBoundingBox(axisAlignedBB)

        if (depth3D) glEnable(GL_DEPTH_TEST)
        glEnable(GL_TEXTURE_2D)
        glDisable(GL_BLEND)
        glDisable(GL_LINE_SMOOTH)
        glDepthMask(true)
        resetColor()
    }

   public static void drawFillBoundingBox(AxisAlignedBB p_147590_0_) {
      ModColor modcolor = Wrapper.getInstance().getActiveModProfile().getBlockOverlay().getFillColor();
      if(modcolor.isEnabled()) {
         ColorUtil.bindColor(modcolor.getColor());
         Tessellator tessellator = Tessellator.getInstance();
         WorldRenderer worldrenderer = tessellator.getWorldRenderer();
         worldrenderer.begin(7, DefaultVertexFormats.POSITION);
         worldrenderer.pos(p_147590_0_.maxX, p_147590_0_.minY, p_147590_0_.maxZ).endVertex();
         worldrenderer.pos(p_147590_0_.maxX, p_147590_0_.maxY, p_147590_0_.maxZ).endVertex();
         worldrenderer.pos(p_147590_0_.minX, p_147590_0_.maxY, p_147590_0_.maxZ).endVertex();
         worldrenderer.pos(p_147590_0_.minX, p_147590_0_.minY, p_147590_0_.maxZ).endVertex();
         tessellator.draw();
         worldrenderer.begin(7, DefaultVertexFormats.POSITION);
         worldrenderer.pos(p_147590_0_.minX, p_147590_0_.minY, p_147590_0_.minZ).endVertex();
         worldrenderer.pos(p_147590_0_.minX, p_147590_0_.maxY, p_147590_0_.minZ).endVertex();
         worldrenderer.pos(p_147590_0_.maxX, p_147590_0_.maxY, p_147590_0_.minZ).endVertex();
         worldrenderer.pos(p_147590_0_.maxX, p_147590_0_.minY, p_147590_0_.minZ).endVertex();
         tessellator.draw();
         worldrenderer.begin(7, DefaultVertexFormats.POSITION);
         worldrenderer.pos(p_147590_0_.minX, p_147590_0_.maxY, p_147590_0_.minZ).endVertex();
         worldrenderer.pos(p_147590_0_.minX, p_147590_0_.maxY, p_147590_0_.maxZ).endVertex();
         worldrenderer.pos(p_147590_0_.maxX, p_147590_0_.maxY, p_147590_0_.maxZ).endVertex();
         worldrenderer.pos(p_147590_0_.maxX, p_147590_0_.maxY, p_147590_0_.minZ).endVertex();
         tessellator.draw();
         worldrenderer.begin(7, DefaultVertexFormats.POSITION);
         worldrenderer.pos(p_147590_0_.minX, p_147590_0_.minY, p_147590_0_.maxZ).endVertex();
         worldrenderer.pos(p_147590_0_.minX, p_147590_0_.minY, p_147590_0_.minZ).endVertex();
         worldrenderer.pos(p_147590_0_.maxX, p_147590_0_.minY, p_147590_0_.minZ).endVertex();
         worldrenderer.pos(p_147590_0_.maxX, p_147590_0_.minY, p_147590_0_.maxZ).endVertex();
         tessellator.draw();
         worldrenderer.begin(7, DefaultVertexFormats.POSITION);
         worldrenderer.pos(p_147590_0_.maxX, p_147590_0_.minY, p_147590_0_.maxZ).endVertex();
         worldrenderer.pos(p_147590_0_.maxX, p_147590_0_.minY, p_147590_0_.minZ).endVertex();
         worldrenderer.pos(p_147590_0_.maxX, p_147590_0_.maxY, p_147590_0_.minZ).endVertex();
         worldrenderer.pos(p_147590_0_.maxX, p_147590_0_.maxY, p_147590_0_.maxZ).endVertex();
         tessellator.draw();
         worldrenderer.begin(7, DefaultVertexFormats.POSITION);
         worldrenderer.pos(p_147590_0_.minX, p_147590_0_.minY, p_147590_0_.minZ).endVertex();
         worldrenderer.pos(p_147590_0_.minX, p_147590_0_.minY, p_147590_0_.maxZ).endVertex();
         worldrenderer.pos(p_147590_0_.minX, p_147590_0_.maxY, p_147590_0_.maxZ).endVertex();
         worldrenderer.pos(p_147590_0_.minX, p_147590_0_.maxY, p_147590_0_.minZ).endVertex();
         tessellator.draw();
      }

   }

   public static void drawSelectionBox(EntityPlayer player, MovingObjectPosition movingObjectPositionIn, int execute, float partialTicks) {
      if(execute == 0 && movingObjectPositionIn.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK) {
         boolean flag = Wrapper.getInstance().getActiveModProfile().getBlockOverlay().isEnabled();
         if(flag) {
            ColorUtil.bindColor(Wrapper.getInstance().getActiveModProfile().getBlockOverlay().getOutlineColor().getColor());
            GL11.glLineWidth((float)Wrapper.getInstance().getActiveModProfile().getBlockOverlay().getThickness());
         } else {
            GlStateManager.color(0.0F, 0.0F, 0.0F, 0.4F);
            GL11.glLineWidth(2.0F);
         }

         GlStateManager.enableBlend();
         GlStateManager.tryBlendFuncSeparate(770, 771, 1, 0);
         GlStateManager.disableTexture2D();
         GlStateManager.depthMask(false);
         float f = 0.002F;
         BlockPos blockpos = movingObjectPositionIn.getBlockPos();
         Block block = Minecraft.getMinecraft().theWorld.getBlockState(blockpos).getBlock();
         if(block.getMaterial() != Material.air && Minecraft.getMinecraft().theWorld.getWorldBorder().contains(blockpos)) {
            block.setBlockBoundsBasedOnState(Minecraft.getMinecraft().theWorld, blockpos);
            double d0 = player.lastTickPosX + (player.posX - player.lastTickPosX) * (double)partialTicks;
            double d1 = player.lastTickPosY + (player.posY - player.lastTickPosY) * (double)partialTicks;
            double d2 = player.lastTickPosZ + (player.posZ - player.lastTickPosZ) * (double)partialTicks;
            AxisAlignedBB axisalignedbb = block.getSelectedBoundingBox(Minecraft.getMinecraft().theWorld, blockpos).expand(0.0020000000949949026D, 0.0020000000949949026D, 0.0020000000949949026D).offset(-d0, -d1, -d2);
            if(Wrapper.getInstance().getActiveModProfile().getBlockOverlay().getOutlineColor().isEnabled() || !flag) {
               drawOutlinedBoundingBox(axisalignedbb);
            }

            if(flag) {
               drawFillBoundingBox(axisalignedbb);
            }
         }

         GlStateManager.depthMask(true);
         GlStateManager.enableTexture2D();
         GlStateManager.disableBlend();
      }

   }

   public static void drawOutlinedBoundingBox(AxisAlignedBB boundingBox) {
      Tessellator tessellator = Tessellator.getInstance();
      WorldRenderer worldrenderer = tessellator.getWorldRenderer();
      worldrenderer.begin(3, DefaultVertexFormats.POSITION);
      worldrenderer.pos(boundingBox.minX, boundingBox.minY, boundingBox.minZ).endVertex();
      worldrenderer.pos(boundingBox.maxX, boundingBox.minY, boundingBox.minZ).endVertex();
      worldrenderer.pos(boundingBox.maxX, boundingBox.minY, boundingBox.maxZ).endVertex();
      worldrenderer.pos(boundingBox.minX, boundingBox.minY, boundingBox.maxZ).endVertex();
      worldrenderer.pos(boundingBox.minX, boundingBox.minY, boundingBox.minZ).endVertex();
      tessellator.draw();
      worldrenderer.begin(3, DefaultVertexFormats.POSITION);
      worldrenderer.pos(boundingBox.minX, boundingBox.maxY, boundingBox.minZ).endVertex();
      worldrenderer.pos(boundingBox.maxX, boundingBox.maxY, boundingBox.minZ).endVertex();
      worldrenderer.pos(boundingBox.maxX, boundingBox.maxY, boundingBox.maxZ).endVertex();
      worldrenderer.pos(boundingBox.minX, boundingBox.maxY, boundingBox.maxZ).endVertex();
      worldrenderer.pos(boundingBox.minX, boundingBox.maxY, boundingBox.minZ).endVertex();
      tessellator.draw();
      worldrenderer.begin(1, DefaultVertexFormats.POSITION);
      worldrenderer.pos(boundingBox.minX, boundingBox.minY, boundingBox.minZ).endVertex();
      worldrenderer.pos(boundingBox.minX, boundingBox.maxY, boundingBox.minZ).endVertex();
      worldrenderer.pos(boundingBox.maxX, boundingBox.minY, boundingBox.minZ).endVertex();
      worldrenderer.pos(boundingBox.maxX, boundingBox.maxY, boundingBox.minZ).endVertex();
      worldrenderer.pos(boundingBox.maxX, boundingBox.minY, boundingBox.maxZ).endVertex();
      worldrenderer.pos(boundingBox.maxX, boundingBox.maxY, boundingBox.maxZ).endVertex();
      worldrenderer.pos(boundingBox.minX, boundingBox.minY, boundingBox.maxZ).endVertex();
      worldrenderer.pos(boundingBox.minX, boundingBox.maxY, boundingBox.maxZ).endVertex();
      tessellator.draw();
   }
}

